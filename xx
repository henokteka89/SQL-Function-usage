---------------------------------------------------------
-- 1) DECLARE the parameters (just like your old proc):
---------------------------------------------------------
DECLARE @DynamicClientID INT = 274748; -- Example
DECLARE @UserID          INT = 47563;  -- Example


---------------------------------------------------------
-- 2) Build the entire query via CTEs:
---------------------------------------------------------
;WITH 
---------------------------------------------------------
-- 2.1) Grab all real ClientIDs for this DynamicClientID
---------------------------------------------------------
DynamicClients AS
(
    SELECT ClientID
    FROM fn_DCG_GetClientIDsForDynamicClientID(@DynamicClientID)
),
---------------------------------------------------------
-- 2.2) The RandomSectionIDs we care about (1..10)
---------------------------------------------------------
Sections AS
(
    SELECT
        randomsectionid,
        menutext,
        menuactionv2,
        [description]
    FROM randomsection WITH (NOLOCK)
    WHERE randomsectionid BETWEEN 1 AND 10
),
---------------------------------------------------------
-- 2.3) Cross-join them: all (ClientID, RandomSectionID)
---------------------------------------------------------
InputGrid AS
(
    SELECT
        dc.ClientID,
        s.randomsectionid,
        s.menutext,
        s.menuactionv2,
        s.[description]
    FROM DynamicClients dc
    CROSS JOIN Sections s
),
---------------------------------------------------------
-- 2.4) Bring in user-level data (myescreenrandomusersectionsettings):
--      No clientid in there => just match on (UserID, RandomSectionID)
---------------------------------------------------------
UserData AS
(
    SELECT
        ig.ClientID,
        @UserID AS UserID,
        ig.RandomSectionID,
        ig.menutext,
        ig.menuactionv2,
        ig.[description],

        us.accessflag  AS UserAccessFlag,   -- might be NULL if no row
        us.SecurityXML AS UserSecurityXML   -- might be NULL if no row
    FROM
        InputGrid ig
        LEFT JOIN myescreenrandomusersectionsettings us
               ON us.UserID          = @UserID
              AND us.RandomSectionID = ig.RandomSectionID
),
---------------------------------------------------------
-- 2.5) Determine each ClientID's type (0=Subaccount, 1=Master, 2=Group)
--      plus find MasterID, GroupID
---------------------------------------------------------
ClientType AS
(
    SELECT
        ca.clientid,
        ca.clientaccount,
        ca.clientsubaccount,
        ne.groupid,
        m.clientid AS MasterID,
        CASE
          WHEN ca.clientsubaccount <> 0 THEN 0  -- subaccount
          WHEN ne.groupid = ca.clientid THEN 2  -- group
          ELSE 1                                -- master
        END AS ClientTypeID
    FROM clientaccounts ca
    LEFT JOIN nationalaccountextras ne
           ON ne.clientid = ca.clientid
    LEFT JOIN clientaccounts m
           ON m.clientaccount    = ca.clientaccount
          AND m.clientsubaccount = 0
),
---------------------------------------------------------
-- 2.6) Reference the client-level table 
--      (myescreenrandomclientsectionsettings)
---------------------------------------------------------
ClientRandom AS
(
    SELECT
        crs.clientid,
        crs.clienttypeid,
        crs.randomsectionid,
        crs.accessflag,
        crs.securityxml
    FROM myescreenrandomclientsectionsettings crs WITH (NOLOCK)
),
---------------------------------------------------------
-- 2.7) "AllData": Join them all so we can do deep nested logic
---------------------------------------------------------
AllData AS
(
    SELECT
        ud.ClientID,
        ud.UserID,
        ud.RandomSectionID,
        ud.UserAccessFlag,
        ud.UserSecurityXML,

        ct.ClientTypeID,
        ct.MasterID,
        ct.groupid,

        ud.menutext,
        ud.menuactionv2,
        ud.[description],

        /* For ClientType=2 (group) row in clientrandom: */
        c2.accessflag    AS c2Access,
        c2.securityxml   AS c2XML,

        /* For ClientType=1 (master) row in clientrandom (plus group row for type=1) */
        c1.accessflag    AS c1Access,
        c1.securityxml   AS c1XML,
        cG1.accessflag   AS cG1Access,
        cG1.securityxml  AS cG1XML,

        /* For ClientType=0 (subaccount) row in clientrandom (plus master row, plus group row) */
        c0.accessflag    AS c0Access,
        c0.securityxml   AS c0XML,
        cM0.accessflag   AS cM0Access,
        cM0.securityxml  AS cM0XML,
        cG0.accessflag   AS cG0Access,
        cG0.securityxml  AS cG0XML
    FROM UserData ud
    INNER JOIN ClientType ct
          ON ct.clientid = ud.ClientID

    -- Group type=2
    LEFT JOIN ClientRandom c2
           ON c2.clientid       = ud.ClientID
          AND c2.clienttypeid   = 2
          AND c2.randomsectionid= ud.RandomSectionID

    -- Master type=1
    LEFT JOIN ClientRandom c1
           ON c1.clientid       = ud.ClientID
          AND c1.clienttypeid   = 1
          AND c1.randomsectionid= ud.RandomSectionID

    -- For group row under type=1 logic
    LEFT JOIN ClientRandom cG1
           ON cG1.clientid       = ct.groupid
          AND cG1.clienttypeid   = 1
          AND cG1.randomsectionid= ud.RandomSectionID

    -- Subaccount type=0
    LEFT JOIN ClientRandom c0
           ON c0.clientid        = ud.ClientID
          AND c0.clienttypeid    = 0
          AND c0.randomsectionid = ud.RandomSectionID

    -- Master row under type=0 logic
    LEFT JOIN ClientRandom cM0
           ON cM0.clientid        = ct.MasterID
          AND cM0.clienttypeid    = 0
          AND cM0.randomsectionid = ud.RandomSectionID

    -- Group row under type=0 logic
    LEFT JOIN ClientRandom cG0
           ON cG0.clientid        = ct.groupid
          AND cG0.clienttypeid    = 0
          AND cG0.randomsectionid = ud.RandomSectionID
),
---------------------------------------------------------
-- 2.8) FinalCalc: Replicate EXACT if/else returns for Avail & SecurityXML
---------------------------------------------------------
FinalCalc AS
(
    SELECT
        ad.ClientID,
        ad.UserID,
        ad.RandomSectionID,

        /* 
          ================== AVAIL LOGIC ==================
          Exactly replicating:
            IF user=0 => Avail=0, RETURN
            ELSE if type=2 => if c2=0 or null => Avail=0, RETURN; else=1,RETURN
            ELSE if type=1 => check c1... else cG1...
            ELSE if type=0 => check c0... else cM0... else cG0...
            Else => 0
        */
        FinalAvail =
            CASE
                WHEN ad.UserAccessFlag = 0
                     THEN 0
                ELSE
                    CASE ad.ClientTypeID
                      WHEN 2
                        THEN
                          CASE
                            WHEN ad.c2Access IS NULL OR ad.c2Access=0
                                 THEN 0
                            ELSE 1
                          END
                      WHEN 1
                        THEN
                          CASE
                            WHEN ad.c1Access IS NULL OR ad.c1Access=0
                                 THEN 0
                            WHEN ad.c1Access=1 AND ad.UserAccessFlag=1
                                 THEN 1
                            ELSE
                              CASE
                                WHEN ad.cG1Access IS NULL OR ad.cG1Access=0
                                     THEN 0
                                WHEN ad.cG1Access=1 AND ad.UserAccessFlag=1
                                     THEN 1
                                ELSE 0
                              END
                          END
                      WHEN 0
                        THEN
                          CASE
                            WHEN ad.c0Access IS NULL OR ad.c0Access=0
                                 THEN 0
                            WHEN ad.c0Access=1 AND ad.UserAccessFlag=1
                                 THEN 1
                            ELSE
                              CASE
                                WHEN ad.cM0Access IS NULL OR ad.cM0Access=0
                                     THEN 0
                                WHEN ad.cM0Access=1 AND ad.UserAccessFlag=1
                                     THEN 1
                                ELSE
                                  CASE
                                    WHEN ad.cG0Access IS NULL OR ad.cG0Access=0
                                         THEN 0
                                    WHEN ad.cG0Access=1 AND ad.UserAccessFlag=1
                                         THEN 1
                                    ELSE 0
                                  END
                              END
                          END
                      ELSE 0
                    END
            END
            AS FinalAvail,

        /*
          ================= SECURITY XML LOGIC =================
          Replicating e.g.:
            IF user=0 => set user’s XML, RETURN
            ELSE IF user’s XML != NULL => keep it, RETURN
            ELSE IF type=2 => if c2=0 or null => Avail=0 => 
                    if userSec=null & c2Sec!=null => userSec=c2Sec => RETURN
                  else c2=1 => if userSec=null => userSec=c2Sec => RETURN
            ETC. 
          That means deeply nested CASEs to respect "IF SecurityXML is still null => set it, else do not".
        */
        FinalSecurityXML =
            CASE
              WHEN ad.UserAccessFlag=0
                   THEN ad.UserSecurityXML   -- short-circuit
              WHEN ad.UserSecurityXML IS NOT NULL
                   THEN ad.UserSecurityXML   -- short-circuit
              ELSE
                /* userSec is still null => we check client type */
                CASE ad.ClientTypeID
                  WHEN 2
                    THEN
                      CASE
                        WHEN ad.c2Access IS NULL OR ad.c2Access=0
                             THEN 
                                CASE
                                  WHEN ad.UserSecurityXML IS NULL 
                                       AND ad.c2XML IS NOT NULL
                                       THEN ad.c2XML
                                  ELSE NULL
                                END
                        ELSE
                          /* c2Access=1 => if userSec was null => set c2XML */
                          CASE
                            WHEN ad.UserSecurityXML IS NULL 
                                 AND ad.c2XML IS NOT NULL
                                 THEN ad.c2XML
                            ELSE NULL
                          END
                      END

                  WHEN 1
                    THEN
                      /* type=1 => check c1 first, if c1=0 => maybe set c1XML, else if c1=1 => c1XML, else check cG1 */
                      CASE
                        WHEN ad.c1Access IS NULL OR ad.c1Access=0
                             THEN
                               CASE
                                 WHEN ad.UserSecurityXML IS NULL AND ad.c1XML IS NOT NULL
                                      THEN ad.c1XML
                                 ELSE NULL
                               END
                        WHEN ad.c1Access=1 AND ad.UserAccessFlag=1
                             THEN
                               CASE
                                 WHEN ad.UserSecurityXML IS NULL AND ad.c1XML IS NOT NULL
                                      THEN ad.c1XML
                                 ELSE NULL
                               END
                        ELSE
                          /* now check cG1 */
                          CASE
                            WHEN ad.cG1Access IS NULL OR ad.cG1Access=0
                                 THEN
                                   CASE
                                     WHEN ad.UserSecurityXML IS NULL AND ad.cG1XML IS NOT NULL
                                          THEN ad.cG1XML
                                     ELSE NULL
                                   END
                            WHEN ad.cG1Access=1 AND ad.UserAccessFlag=1
                                 THEN
                                   CASE
                                     WHEN ad.UserSecurityXML IS NULL AND ad.cG1XML IS NOT NULL
                                          THEN ad.cG1XML
                                     ELSE NULL
                                   END
                            ELSE NULL
                          END
                      END

                  WHEN 0
                    THEN
                      /* subaccount => c0 => cM0 => cG0, each with the if userSec=null => set it logic */
                      CASE
                        WHEN ad.c0Access IS NULL OR ad.c0Access=0
                             THEN
                               CASE
                                 WHEN ad.UserSecurityXML IS NULL AND ad.c0XML IS NOT NULL
                                      THEN ad.c0XML
                                 ELSE NULL
                               END
                        WHEN ad.c0Access=1 AND ad.UserAccessFlag=1
                             THEN
                               CASE
                                 WHEN ad.UserSecurityXML IS NULL AND ad.c0XML IS NOT NULL
                                      THEN ad.c0XML
                                 ELSE NULL
                               END
                        ELSE
                          CASE
                            WHEN ad.cM0Access IS NULL OR ad.cM0Access=0
                                 THEN
                                   CASE
                                     WHEN ad.UserSecurityXML IS NULL AND ad.cM0XML IS NOT NULL
                                          THEN ad.cM0XML
                                     ELSE NULL
                                   END
                            WHEN ad.cM0Access=1 AND ad.UserAccessFlag=1
                                 THEN
                                   CASE
                                     WHEN ad.UserSecurityXML IS NULL AND ad.cM0XML IS NOT NULL
                                          THEN ad.cM0XML
                                     ELSE NULL
                                   END
                            ELSE
                              CASE
                                WHEN ad.cG0Access IS NULL OR ad.cG0Access=0
                                     THEN
                                       CASE
                                         WHEN ad.UserSecurityXML IS NULL AND ad.cG0XML IS NOT NULL
                                              THEN ad.cG0XML
                                         ELSE NULL
                                       END
                                WHEN ad.cG0Access=1 AND ad.UserAccessFlag=1
                                     THEN
                                       CASE
                                         WHEN ad.UserSecurityXML IS NULL AND ad.cG0XML IS NOT NULL
                                              THEN ad.cG0XML
                                         ELSE NULL
                                       END
                                ELSE NULL
                              END
                          END
                      END

                  ELSE NULL
                END
            END
            AS FinalSecurityXML,

        ad.menutext,
        ad.menuactionv2,
        ad.[description]
    FROM AllData ad
),
---------------------------------------------------------
-- 2.9) Aggregate if your old code sets "UserSectionXAvail=1"
--      whenever ANY client is found =1
---------------------------------------------------------
AggResult AS
(
    SELECT
        fc.RandomSectionID,
        -- If ANY row =1 => aggregator =1
        CAST(MAX(fc.FinalAvail) AS BIT) AS UserAvail,

        /* 
           For SecurityXML, your original code effectively 
           picks whichever row "returns" first in the loop. 
           If you want that EXACT sequence, you'd need 
           an ORDER BY. For now, we do MAX(...) 
           or you can do MIN(...) 
        */
        MAX(fc.FinalSecurityXML) AS SecurityXML,

        MAX(fc.menutext) AS menutext,
        MAX(fc.menuactionv2) AS menuactionv2,
        MAX(fc.[description]) AS [description]
    FROM FinalCalc fc
    GROUP BY 
        fc.RandomSectionID
)

---------------------------------------------------------
-- 3) SELECT the final rows (like the old proc ends with)
---------------------------------------------------------
SELECT
    a.UserAvail        AS UserAvail,
    a.SecurityXML      AS SecurityXML,
    a.menutext         AS menutext,
    a.menuactionv2     AS menuactionv2,
    a.RandomSectionID  AS RandomSectionID,
    a.[description]    AS [description]
FROM AggResult a
ORDER BY a.RandomSectionID;