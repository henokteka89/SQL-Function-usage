CREATE OR ALTER PROCEDURE [dbo].[usp_MyEUsers_Get_RandomsSubMenu_Blend]
(
    @ClientID        INT,
    @DynamicClientID INT,
    @UserID          INT
)
AS
BEGIN
    SET NOCOUNT ON;

    ----------------------------------------------------------------------------
    -- 1) Build a list of all clientIDs (including subaccounts) from 
    --    the dynamic client function, if @DynamicClientID is used.
    ----------------------------------------------------------------------------

    IF OBJECT_ID('tempdb..#clientIDs') IS NOT NULL
        DROP TABLE #clientIDs;

    IF @DynamicClientID IS NOT NULL
    BEGIN
        SELECT ClientID
        INTO #clientIDs
        FROM fn_DCG_GetClientIDsForDynamicClientID(@DynamicClientID);
    END
    ELSE
    BEGIN
        -- If no @DynamicClientID, just use the one @ClientID
        SELECT @ClientID AS ClientID
        INTO #clientIDs;
    END

    ----------------------------------------------------------------------------
    -- 2) Collect the random sections (IDs 1..10). 
    --    Adjust if your real randomsection table uses different ranges.
    ----------------------------------------------------------------------------

    IF OBJECT_ID('tempdb..#RandomSections') IS NOT NULL
        DROP TABLE #RandomSections;

    CREATE TABLE #RandomSections
    (
        RandomSectionID INT PRIMARY KEY,
        MenuText        VARCHAR(100),
        MenuActionV2    VARCHAR(200),
        Description     VARCHAR(100)
    );

    INSERT INTO #RandomSections (RandomSectionID, MenuText, MenuActionV2, Description)
    SELECT RandomSectionID,
           MenuText,
           MenuActionV2,
           Description
    FROM randomsection (NOLOCK)
    WHERE RandomSectionID BETWEEN 1 AND 10;

    ----------------------------------------------------------------------------
    -- 3) Determine user availability in bulk. 
    --    Also retrieve user’s SecurityXML if the user has a row.
    ----------------------------------------------------------------------------

    IF OBJECT_ID('tempdb..#UserAvailability') IS NOT NULL
        DROP TABLE #UserAvailability;

    CREATE TABLE #UserAvailability
    (
        RandomSectionID INT PRIMARY KEY,
        UserAvail       INT,           -- 0 or 1
        SecurityXML     VARCHAR(1000)  -- from myescreenrandomusersectionsettings
    );

    -- Step A: Insert a row for each random section (initially unknown).
    INSERT INTO #UserAvailability(RandomSectionID, UserAvail)
    SELECT rs.RandomSectionID,
        CASE 
            -- If user specifically sets AccessFlag=0 in myescreenrandomusersectionsettings => Deny
            WHEN EXISTS (
                SELECT 1 
                FROM myescreenrandomusersectionsettings uss (NOLOCK)
                WHERE uss.UserID          = @UserID
                  AND uss.RandomSectionID = rs.RandomSectionID
                  AND uss.AccessFlag      = 0
            ) THEN 0
            -- If user specifically sets AccessFlag=1 => Granted
            WHEN EXISTS (
                SELECT 1
                FROM myescreenrandomusersectionsettings uss (NOLOCK)
                WHERE uss.UserID          = @UserID
                  AND uss.RandomSectionID = rs.RandomSectionID
                  AND uss.AccessFlag      = 1
            ) THEN 1
            -- Otherwise, user has no row => treat as “no override.” 
            -- (Your old code typically ended up with 0 if no row, but you can adapt.)
            ELSE 0
        END AS UserAvail
    FROM #RandomSections rs;

    -- Step B: Fill in the user’s SecurityXML if the user has a myescreenrandomusersectionsettings row
    UPDATE ua
       SET ua.SecurityXML = uss.SecurityXML
    FROM #UserAvailability ua
    JOIN myescreenrandomusersectionsettings uss (NOLOCK)
       ON uss.UserID          = @UserID
      AND uss.RandomSectionID = ua.RandomSectionID
    WHERE uss.AccessFlag = ua.UserAvail
      -- i.e., match the same row that gave us 0 or 1 
      -- (if you prefer to always take user’s row even if AccessFlag differs, remove this filter)

    ----------------------------------------------------------------------------
    -- 4) Determine client availability with full type/hierarchy logic in set-based manner.
    --    We need to figure out: subaccount => ClientTypeID=0, 
    --                           a Master => 1, 
    --                           a Group => 2, 
    --    and then pick “grant or deny” from myescreenrandomclientsectionsettings.
    ----------------------------------------------------------------------------

    IF OBJECT_ID('tempdb..#FilteredClients') IS NOT NULL
        DROP TABLE #FilteredClients;

    -- #FilteredClients: each row is a single client from #clientIDs, plus:
    --    - ClientTypeID
    --    - MasterID
    --    - GroupID
    CREATE TABLE #FilteredClients
    (
        ClientID      INT,
        ClientTypeID  INT,  -- 0 = subaccount, 1 = master, 2 = group
        MasterID      INT,  
        GroupID       INT
    );

    INSERT INTO #FilteredClients (ClientID, ClientTypeID, MasterID, GroupID)
    SELECT 
       ca.ClientID,
       CASE 
           WHEN ca.ClientSubaccount <> 0 THEN 0
           WHEN EXISTS (
               SELECT 1 FROM nationalaccountextras nae (NOLOCK)
               WHERE nae.GroupID = ca.ClientID
           ) THEN 2
           ELSE 1
       END AS ClientTypeID,
       (SELECT TOP 1 caMaster.ClientID 
        FROM clientaccounts caMaster (NOLOCK)
        WHERE caMaster.ClientAccount   = ca.ClientAccount
          AND caMaster.ClientSubaccount= 0
       ) AS MasterID,
       (SELECT TOP 1 nae.ClientID 
        FROM nationalaccountextras nae (NOLOCK)
        WHERE nae.ClientID = ca.ClientID
       ) AS GroupID
    FROM #clientIDs c
    JOIN clientaccounts ca (NOLOCK) 
      ON ca.ClientID = c.ClientID;

    ----------------------------------------------------------------------------
    -- 5) Construct a big table #ClientAvailability with one row per 
    --    (RandomSectionID, ClientID) indicating AccessFlag=1 or 0 plus SecurityXML.
    --    We’ll unify them afterwards (some clients might re-appear with different results).
    ----------------------------------------------------------------------------

    IF OBJECT_ID('tempdb..#ClientAvailabilityRaw') IS NOT NULL
        DROP TABLE #ClientAvailabilityRaw;

    CREATE TABLE #ClientAvailabilityRaw
    (
        RandomSectionID INT,
        ClientID        INT,
        ClientTypeID    INT,
        ClientAvail     INT,           -- 0 or 1
        SecurityXML     VARCHAR(1000)
    );

    ----------------------------------------------------------------------------
    -- 5A) Insert “granted” or “denied” rows from myescreenrandomclientsectionsettings
    --     for all the #FilteredClients.  We do an OUTER JOIN so we can see if
    --     there’s “no row,” which typically means deny = 0.  Or we replicate exactly
    --     your old logic with subaccount => fallback to master => fallback to group. 
    --
    --     However, we can do it in a single pass if we treat "no row" as 0, 
    --     or we can do separate steps. Here’s a simpler approach:
    ----------------------------------------------------------------------------

    INSERT INTO #ClientAvailabilityRaw (RandomSectionID, ClientID, ClientTypeID, ClientAvail, SecurityXML)
    SELECT 
       rs.RandomSectionID,
       fc.ClientID,
       fc.ClientTypeID,
       CASE 
          WHEN css.AccessFlag = 1 THEN 1
          ELSE 0
       END AS ClientAvail,
       css.SecurityXML
    FROM #FilteredClients fc
    CROSS JOIN #RandomSections rs
    LEFT JOIN myescreenrandomclientsectionsettings css (NOLOCK)
         ON css.ClientID        = fc.ClientID
        AND css.ClientTypeID    = fc.ClientTypeID
        AND css.RandomSectionID = rs.RandomSectionID;

    -- Explanation:
    --   1) CROSS JOIN #RandomSections => we get 1 row per client + 1..10 sections
    --   2) LEFT JOIN myescreenrandomclientsectionsettings => see if client has a row
    --   3) If row’s AccessFlag=1 => ClientAvail=1, else 0. 
    --   4) If no row, we get css = null => treat that as 0. 

    ----------------------------------------------------------------------------
    -- 5B) For subaccounts or masters that also need to fallback to MasterID or GroupID, 
    --     we replicate your old code that tries each “layer.” 
    --     The simplest approach is to union them in, then take the max or do priority logic.
    ----------------------------------------------------------------------------

    -- Subaccount fallback (subaccount => 0 => check Master => 0 => check Group)
    -- Let's do a second pass for the Master row, if the subaccount doesn't grant it:

    INSERT INTO #ClientAvailabilityRaw (RandomSectionID, ClientID, ClientTypeID, ClientAvail, SecurityXML)
    SELECT 
       rs.RandomSectionID,
       fc.ClientID,               -- the subaccount 
       0              AS ClientTypeID,   -- subaccount 
       CASE WHEN cssMaster.AccessFlag = 1 THEN 1 ELSE 0 END,
       cssMaster.SecurityXML
    FROM #FilteredClients fc
    CROSS JOIN #RandomSections rs
    JOIN clientaccounts caSub (NOLOCK)
      ON caSub.ClientID = fc.ClientID
    LEFT JOIN myescreenrandomclientsectionsettings cssMaster (NOLOCK)
         ON cssMaster.ClientID = fc.MasterID
        AND cssMaster.ClientTypeID = 0     -- Master is also type=0 if we assume subaccount = 0? 
        AND cssMaster.RandomSectionID = rs.RandomSectionID
    WHERE fc.ClientTypeID = 0;  -- only subaccounts do this fallback

    -- Then fallback to Group from that subaccount’s group, if any:

    INSERT INTO #ClientAvailabilityRaw (RandomSectionID, ClientID, ClientTypeID, ClientAvail, SecurityXML)
    SELECT 
       rs.RandomSectionID,
       fc.ClientID,
       0 AS ClientTypeID,
       CASE WHEN cssGroup.AccessFlag = 1 THEN 1 ELSE 0 END,
       cssGroup.SecurityXML
    FROM #FilteredClients fc
    CROSS JOIN #RandomSections rs
    LEFT JOIN myescreenrandomclientsectionsettings cssGroup (NOLOCK)
         ON cssGroup.ClientID        = fc.GroupID
        AND cssGroup.ClientTypeID    = 0
        AND cssGroup.RandomSectionID = rs.RandomSectionID
    WHERE fc.ClientTypeID = 0; -- subaccount => possibly fallback to group

    -- Similar logic for Master => fallback to group if it’s a “master” type=1:
    INSERT INTO #ClientAvailabilityRaw (RandomSectionID, ClientID, ClientTypeID, ClientAvail, SecurityXML)
    SELECT 
       rs.RandomSectionID,
       fc.ClientID,
       1 AS ClientTypeID,
       CASE WHEN cssGroup.AccessFlag = 1 THEN 1 ELSE 0 END,
       cssGroup.SecurityXML
    FROM #FilteredClients fc
    CROSS JOIN #RandomSections rs
    LEFT JOIN myescreenrandomclientsectionsettings cssGroup (NOLOCK)
         ON cssGroup.ClientID        = fc.GroupID
        AND cssGroup.ClientTypeID    = 1
        AND cssGroup.RandomSectionID = rs.RandomSectionID
    WHERE fc.ClientTypeID = 1; 

    ----------------------------------------------------------------------------
    -- 5C) Now unify #ClientAvailabilityRaw down to a single row for each 
    --     (ClientID, RandomSectionID) by picking the “best” availability 
    --     and the “most relevant” SecurityXML. This is like your old code 
    --     that sets Avail=1 if any layer says 1, else 0, etc.
    ----------------------------------------------------------------------------

    IF OBJECT_ID('tempdb..#ClientAvailability') IS NOT NULL
        DROP TABLE #ClientAvailability;

    CREATE TABLE #ClientAvailability
    (
        RandomSectionID INT,
        ClientID        INT,
        ClientAvail     INT,
        SecurityXML     VARCHAR(1000)
    );

    ;WITH cte AS
    (
       SELECT
         car.RandomSectionID,
         car.ClientID,
         -- Priority: if any row is "1" => top. If all are "0" => second.
         -- We'll map Avail=1 => Priority=2, Avail=0 => Priority=1:
         CASE WHEN car.ClientAvail=1 THEN 2 ELSE 1 END AS Priority,
         car.ClientAvail,
         car.SecurityXML,
         ROW_NUMBER() OVER (
            PARTITION BY car.ClientID, car.RandomSectionID
            ORDER BY 
               CASE WHEN car.ClientAvail=1 THEN 2 ELSE 1 END DESC,
               (CASE WHEN car.SecurityXML IS NOT NULL THEN 1 ELSE 0 END) DESC
         ) AS rn
       FROM #ClientAvailabilityRaw car
    )
    INSERT INTO #ClientAvailability (RandomSectionID, ClientID, ClientAvail, SecurityXML)
    SELECT
       RandomSectionID,
       ClientID,
       ClientAvail,
       SecurityXML
    FROM cte
    WHERE rn = 1;  -- pick the best row for each client & random section

    ----------------------------------------------------------------------------
    -- 6) Finally, we want to combine across all #clientIDs to see if *any* 
    --    client is granted => that yields final ClientAvail=1 for that random section.
    --    If all are 0 => final is 0. And we pick the first “grant” XML if available.
    --
    --    For the user’s old logic, if ANY subaccount (or child) is 1 => user sees 1. 
    --    So we do a GROUP BY with a similar “priority” approach.
    ----------------------------------------------------------------------------

    IF OBJECT_ID('tempdb..#ClientAvailabilityGrouped') IS NOT NULL
        DROP TABLE #ClientAvailabilityGrouped;

    CREATE TABLE #ClientAvailabilityGrouped
    (
        RandomSectionID INT PRIMARY KEY,
        ClientAvail     INT,
        SecurityXML     VARCHAR(1000)
    );

    ;WITH cte2 AS
    (
       SELECT
          ca.RandomSectionID,
          CASE WHEN ca.ClientAvail=1 THEN 2 ELSE 1 END AS Priority,
          ca.ClientAvail,
          ca.SecurityXML,
          ROW_NUMBER() OVER (
             PARTITION BY ca.RandomSectionID
             ORDER BY 
               CASE WHEN ca.ClientAvail=1 THEN 2 ELSE 1 END DESC,
               (CASE WHEN ca.SecurityXML IS NOT NULL THEN 1 ELSE 0 END) DESC
          ) AS rn
       FROM #ClientAvailability ca
    )
    INSERT INTO #ClientAvailabilityGrouped (RandomSectionID, ClientAvail, SecurityXML)
    SELECT
       RandomSectionID,
       ClientAvail,
       SecurityXML
    FROM cte2
    WHERE rn = 1;  -- pick best row per random section across ALL clients

    ----------------------------------------------------------------------------
    -- 7) Combine final results:
    --    - If userAvail=0 => final user is denied => overall=0
    --    - else if client=0 => overall=0
    --    - else overall=1
    --
    --    For SecurityXML:
    --       if userAvail=0 => user’s deny XML
    --       else if user’s SecurityXML is not null => user’s XML
    --       else if client’s SecurityXML is not null => client’s XML
    --       else null
    ----------------------------------------------------------------------------

    SELECT 
       CAST(cg.ClientAvail AS BIT) AS ClientAvail, 
       CASE 
          WHEN ua.UserAvail = 0 THEN 0       -- user explicitly denied
          WHEN cg.ClientAvail = 0 THEN 0     -- client collectively denied
          ELSE 1
       END AS UserAvail,
       CASE
          WHEN ua.UserAvail = 0 THEN ua.SecurityXML
          WHEN ua.SecurityXML IS NOT NULL THEN ua.SecurityXML
          WHEN cg.SecurityXML IS NOT NULL THEN cg.SecurityXML
          ELSE NULL
       END AS SecurityXML,
       rs.MenuText,
       rs.MenuActionV2,
       rs.RandomSectionID,
       rs.Description
    FROM #RandomSections rs
    JOIN #ClientAvailabilityGrouped cg 
      ON cg.RandomSectionID = rs.RandomSectionID
    JOIN #UserAvailability ua
      ON ua.RandomSectionID = rs.RandomSectionID
    ORDER BY rs.RandomSectionID;

    SET NOCOUNT OFF;
END;
GO